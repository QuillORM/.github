
# 1. Introduction
### 1.1. What is the goal of QuillORM?
QuillORM amis to be a "feather-light quill for Kotlin object relational mapping", but what does that mean?

The "feather-light" parts reassembles the aim of QuillORM to be a lightweight framework,
that requires as little configuration as only given the information for the database connection.

The "quill" stands for the aim to provide a fluent, easy to use API, that is easy to understand and takes over
the responsibility of the developer to write the SQL queries.

The "Kotlin" part is clear, QuillORM is written and designed for Kotlin.

The "object relational mapping" part is the most important part of QuillORM. QuillORM maps the date from your database
to data a developer can easily work with. This is done by **generating models** based on the database structure.

## 1.2. Why another ORM?
You may already know many Kotlin ORM frameworks: "Exposed", "Ktorm" and "Hybernate" only to name a few.

**So why another ORM?**

We, as the main developers of QuillORM have looked into many of these existing ORM frameworks,
but all of them have their downsides, we don't want to state, that QuillORM won't have downsides, but we think,
that existing ORMs do not make the right trade-offs for our use cases.

Some of the main downsides are:
- **Duplicate writing of structure**: Most ORMs required the developer to describe the database in two ways,
  as a schema and as models. This basically doubles the required work of the developer, without any benefit.
- **No migrations**: Most ORMs do not provide a way to migrate the database, which is a huge downside,
  as the database structure is not static and will change over time. For this reason, QuillORM introduces Evolutions,
  more on that later.
- **No model generation**: In most ORMs, as already mentioned, the developer has to write the models by hand,
  but the developer already has to write the schema, so why not generate the models from the schema?
  This provides some more benefits, but more on that also later.
- **Not Kotlin first**: Most ORMs are written in Java and therefore do not provide a fluent API for Kotlin.
  Kotlin has many nice and useful features, that can not be used when developing a library in Java,
  which is the case for many ORMs.

That are, among some others, the most important downsides of existing ORMs, that QuillORM tries to solve.

## 1.3. The key concept: Structure only
The key concept of QuillORM is that the developer is only required to write the structure of the tables,
everything else is generated by QuillORM.

The best thing of all, the structures are versioned, 
so you can easily migrate between different versions of your table.

In addition to the versioning of the structure, you can define transformations, that describe, 
how the data is transformed from one version to another.

You can find more on structures in the [chapter about it](TableStructure.md#4-table-structure).

[Back: Table of Contents](Concept.md#table-of-contents) | [Next: JDBC Shell](JDBCShell.md#2-jdbc-shell)